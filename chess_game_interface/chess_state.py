from chess_game_interface.two_player_games.two_player_games.state import State
from chess_game_interface.two_player_games.two_player_games.player import (
    Player,
)
from chess_game_interface.chess_exceptions import (
    InvalidMoveException,
    IncorrectPieceTypeException,
    WhitePlayerNotInTheGameException,
)
from chess_game_interface.chess_pieces import (
    ChessPiece,
    Pawn,
    Knight,
    Bishop,
    Rook,
    Queen,
    King,
)
from chess_game_interface.chess_move import ChessMove
from typing import Iterable, List, Optional


class ChessState(State):
    """
    A class representing a state in a chess game.


    Attributes:

    _current_player : Player
        represents
    """

    def __init__(
        self,
        current_player: Player,
        other_player: Player,
        white: Player = None,
        board: List[List[ChessPiece]] = None,
    ):
        """
        ChessState class constructor.


        Parameters:

        current_player : Player
            a Player object which represents the player whose move is now

        other_player : Player
            a Player object which represents the player who is waiting for
            their move

        white : Player
            a Player object which represents the player playing white pieces.
            This parameter must be equal to either current_player or
            other_player

        board : List[List[ChessPiece]]
            a two-dimensional list with ChessPiece objects representing the
            chess board (empty fields are represented by the None values)
        """
        if board:
            self._board = board
        else:
            if white not in (current_player, other_player, None):
                raise WhitePlayerNotInTheGameException
            white = white or current_player
            black = other_player if current_player == white else current_player
            self._board = [
                [
                    Rook(0, 0, white),
                    Knight(1, 0, white),
                    Bishop(2, 0, white),
                    Queen(3, 0, white),
                    King(4, 0, white),
                    Bishop(5, 0, white),
                    Knight(6, 0, white),
                    Rook(7, 0, white),
                ],
                [Pawn(column_index, 1, white) for column_index in range(8)],
                [None for column in range(8)],
                [None for column in range(8)],
                [None for column in range(8)],
                [None for column in range(8)],
                [Pawn(column_index, 6, black) for column_index in range(8)],
                [
                    Rook(0, 7, black),
                    Knight(1, 7, black),
                    Bishop(2, 7, black),
                    Queen(3, 7, black),
                    King(4, 7, black),
                    Bishop(5, 7, black),
                    Knight(6, 7, black),
                    Rook(7, 7, black),
                ],
            ]

        self._current_player = current_player
        self._other_player = other_player

        self._white = white or current_player

    def get_moves(self) -> Iterable[ChessMove]:
        """
        Returns a list of moves generated by _get_moves method by each of
        the ChessPiece object on the board belonging to the current player.
        """
        result = []

        for row in self._board:
            for piece in row:
                piece_moves = []
                if (
                    piece is not None
                    and piece.player() == self._current_player
                ):
                    piece_moves = piece._get_moves(self)
                result += piece_moves
        return result

    def get_current_player(self) -> Player:
        """Returns a Player object representing a player who is currently
        playing the move."""
        return self._current_player

    def _get_current_players_king(self) -> King:
        """Returns a King object representing current players king."""
        for row in self._board:
            for square in row:
                if (
                    square is not None
                    and type(square) == King
                    and square.player() == self._current_player
                ):
                    return square

    def _make_piece(
        self,
        piece_type: type,
        column: int,
        row: int,
        player: Player,
        first_move_or_can_castle=False,
        is_en_passantable=False,
    ) -> ChessPiece:
        """
        Returns an object of one of the child classes of the ChessPiece class.
        This method is meant to serve as a unified 'constructor' for each of
        the aforementioned classes. Raises an exception if a wrong piece type
        is given.


        Parameters:

        piece_type : type
            a type of the piece to be constructed

        column : int
            an integer representing the column of a square that the piece
            resides on

        row : int
            an integer representing the row of a square that the piece
            resides on

        player : Player
            a Player object representing a player to which the piece belongs

        first_move_or_can_castle : bool
            a bool that determines if a pawn has the possibility of making
            a move by two squares forward (as its first move) or if a king
            or a rook can castle

        is_en_passantable : bool
            a bool that determines if a pawn can be taken en passant
        """
        if piece_type == Pawn:
            return Pawn(
                column,
                row,
                player,
                first_move_or_can_castle,
                is_en_passantable,
            )
        elif piece_type in (Rook, King):
            return piece_type(
                column,
                row,
                player,
                first_move_or_can_castle,
            )
        elif piece_type in (Knight, Bishop, Queen):
            return piece_type(
                column,
                row,
                player,
            )
        else:
            raise IncorrectPieceTypeException

    def _piece_shift(
        self,
        move: ChessMove,
        moved_piece: ChessPiece,
        first_move_or_can_castle=False,
        is_en_passantable=False,
    ) -> List[List[ChessPiece]]:
        """
        Returns a two dimensional list representing a chess board after making
        a shift of a piece from one square to another. first_move_or_can_castle
        and is_en_passantable optional arguments allow for passing additional
        arguments when dealing with pieces that need them (Pawn, Rook, King).


        Parameters:

        move : ChessMove
            a ChessMove object representing the move (shift) to be made

        moved_piece : ChessPiece
            a ChessPiece object representing the piece being moved

        first_move_or_can_castle : bool
            a bool that determines if a pawn has the possibility of making
            a move by two squares forward (as its first move) or if a king
            or a rook can castle

        is_en_passantable : bool
            a bool that determines if a pawn can be taken en passant
        """
        new_board = [[square for square in row] for row in self._board]
        new_board[move.start_row()][move.start_column()] = None
        new_board[move.end_row()][move.end_column()] = self._make_piece(
            type(moved_piece),
            move.end_column(),
            move.end_row(),
            moved_piece.player(),
            first_move_or_can_castle,
            is_en_passantable,
        )
        return new_board

    def _evaluate_pawn_scenarios(
        self,
        move: ChessMove,
        moved_pawn: Pawn,
        promotion_type: type = None,
    ) -> List[List[ChessPiece]]:
        """
        A helper method used by the make_move function whenever a pawn move is
        detected. Returns a two dimensional list representing a board after
        making a move. This method is used for handling promotion and en
        passant among regular moves and taking.


        Parameters:

        move : ChessMove
            a ChessMove object representing the move being made

        moved_pawn : Pawn
            a Pawn object representing the pawn being moved

        promotion_type : type
            a type that represents the class of a piece to which the pawn will
            promote
        """
        row_shift = move.end_row() - move.start_row()
        column_shift = move.end_column() - move.start_column()

        if self.is_promotion(move):
            if promotion_type in (Knight, Bishop, Rook, Queen):
                moved_pawn = self._make_piece(
                    promotion_type,
                    moved_pawn.column(),
                    moved_pawn.row(),
                    moved_pawn.player(),
                    False,
                )
            else:
                raise IncorrectPieceTypeException

        # first move
        if row_shift in (-2, 2):
            new_board = self._piece_shift(
                move,
                moved_pawn,
                False,
                True,
            )

        # en passant and taking
        elif column_shift in (-1, 1):
            piece_next_to_the_pawn = self._board[moved_pawn.row()][
                move.end_column()
            ]
            piece_pawn_end_position = self._board[move.end_row()][
                move.end_column()
            ]
            if (
                piece_next_to_the_pawn is not None
                and type(piece_next_to_the_pawn) == Pawn
                and piece_next_to_the_pawn.player() != moved_pawn.player()
                and piece_next_to_the_pawn.is_en_passantable()
            ):
                new_board = self._piece_shift(
                    move,
                    moved_pawn,
                )
                new_board[moved_pawn.row()][move.end_column()] = None
            elif (
                piece_pawn_end_position is not None
                and piece_pawn_end_position.player() == self._other_player
            ):
                new_board = self._piece_shift(
                    move,
                    moved_pawn,
                )
            else:
                raise InvalidMoveException

        else:  # move forward by one square
            new_board = self._piece_shift(
                move,
                moved_pawn,
            )

        return new_board

    def _is_in_check(self) -> bool:
        """
        Checks if current players king is under check by checking if an enemy
        can PHYSICALLY move onto the square that the king occupies. Returns
        True if that's the case.
        """
        state_switched_sides = ChessState(
            self._other_player,
            self._current_player,
            self._white,
            self._board,
        )
        current_king = self._get_current_players_king()
        current_king_pos = (current_king.column(), current_king.row())
        state_switched_sides_end_positions = [
            (move.end_column(), move.end_row())
            for move in state_switched_sides.get_moves()
        ]
        if current_king_pos in state_switched_sides_end_positions:
            return True
        return False

    def _evaluate_castling_scenarios(
        self,
        move: ChessMove,
        moved_piece: King,
        board: List[List[ChessPiece]],
    ) -> List[List[ChessPiece]]:
        """
        A helper method used by the make_move function whenever a castling move
        is detected. Returns a two dimensional list representing a board after
        making a move. This method raises an error if the move cannot be made
        due to the squares between the king and the rook being under attack.


        Parameters:

        move : ChessMove
            a ChessMove object representing the move being made

        moved_pawn : King
            a King object representing the king being moved

        board: List[List[ChessPiece]]
            a two dimensional list representing the board after the initial
            king move has been made (because the king part of castling move
            is made in the make_move method there had to be a way to provide
            an already modified board, with the king already moved, to the
            function)
        """
        new_board = [[square for square in row] for row in board]

        squares_enemy_can_attack = [
            (enemy_move.end_column(), enemy_move.end_row())
            for enemy_move in ChessState(
                self._other_player,
                self._current_player,
                self._white,
                self._board,
            ).get_moves()
        ]

        king_shift_dir = move.end_column() - move.start_column()
        king_shift_dir = king_shift_dir // abs(king_shift_dir)

        squares_to_check = (
            (column, 0)
            for column in range(
                4, move.end_column() + king_shift_dir, king_shift_dir
            )
        )

        if any(
            square in squares_enemy_can_attack for square in squares_to_check
        ):

            raise InvalidMoveException

        else:

            new_board[0][4 + king_shift_dir] = self._make_piece(
                Rook, 4 + king_shift_dir, 0, self._current_player, False
            )

            new_board[0][int(3.5 + 3.5 * king_shift_dir)] = None

        return new_board

    def _reset_en_passantable_pawns(self):
        """
        Sets the is_en_passantable flag on each pawn of the current player that
        made a move forward by two squares and had the flag on True to False.
        """
        row = 3 if self._current_player == self._white else 4
        for piece in self._board[row]:
            if (
                piece is not None
                and type(piece) == Pawn
                and piece.player() == self._current_player
                and piece.is_en_passantable()
            ):
                self._board[row][piece.column()] = Pawn(
                    piece.column(), row, self._current_player, False, False
                )

    def make_move(
        self, move: ChessMove, promotion_type: type = None
    ) -> "ChessState":
        """
        Returns a new state after making a move. If a move was in any way
        invalid it raises an appropriate exception. This method takes into
        consideration the legality of the move player (checks if, for example,
        a piece has been blocked, king is under check and the move can't be
        made, an en passant can't be made because the enemy pawn made the first
        move by two squares not right before the current players move and so
        on). It also calls the _reset_en_passantable_pawns method to reset the
        pawns that had the is_en_passantable flag set to True back to false.


        Parameters:

        move : ChessMove
            a ChessMove object representing the move being made

        promotion_type : type
            a type that represents the class of a piece to which the pawn will
            promote (only used for pawn promotion)
        """
        self._reset_en_passantable_pawns()

        moved_piece = self._board[move.start_row()][move.start_column()]
        valid_moves = self.get_moves()
        if move not in valid_moves:
            raise InvalidMoveException

        if type(moved_piece) == Pawn:
            new_board = self._evaluate_pawn_scenarios(
                move, moved_piece, promotion_type
            )

        else:
            new_board = self._piece_shift(
                move,
                moved_piece,
            )

        if type(moved_piece) == King and move in (
            ChessMove(4, 0, 2, 0),
            ChessMove(4, 0, 6, 0),
        ):
            new_board = self._evaluate_castling_scenarios(
                move, moved_piece, new_board
            )

        new_state = ChessState(
            self._other_player, self._current_player, self._white, new_board
        )

        new_state_current_player = ChessState(
            self._current_player, self._other_player, self._white, new_board
        )

        if new_state_current_player._is_in_check():
            raise InvalidMoveException

        return new_state

    def is_promotion(self, move: ChessMove) -> bool:
        """
        Returns True if a move will result in a promotion.


        Parameters:

        move : ChessMove
            a ChessMove object representing a move
        """
        moved_piece = self._board[move.start_row()][move.start_column()]
        if (
            moved_piece is not None
            and type(moved_piece) == Pawn
            and move.end_row()
            == (7 if moved_piece.player() == self._white else 0)
        ):
            return True
        return False

    def is_finished(self) -> bool:
        """
        Returns True if the game has been finished (there are no more legal
        moves to be made).
        """
        get_moves_list = self.get_moves()
        for move in get_moves_list:
            try:
                self.make_move(move)
                return False
            except InvalidMoveException:
                continue
        return True

    def get_winner(self) -> Optional[Player]:
        """
        Returns a Player object that represents the winning player if one
        of the sides won the game or None if there was a draw.
        """
        if self.is_finished() and self._is_in_check():
            return self._other_player
        return None

    def __str__(self) -> str:
        """Returns a string representing the current state of the board."""
        return "".join(
            [
                ("".join([f"{piece} " if piece else "   " for piece in row]))
                + "\n"
                for row in reversed(self._board)
            ]
        )
